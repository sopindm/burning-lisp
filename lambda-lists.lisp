(in-package #:burning-lisp)

(defun lambda-list-keyword-p (arg)
  (and (symbolp arg) 
       (let ((name (symbol-name arg)))
	 (and (char= (char name 0) #\&) (> (length name) 1)))))

(defun find-lambda-list-keyword (keyword list)
  (cond
    ((null list) nil)
    ((null keyword) (remove-lambda-list-keywords list))
    ((eq (first list) keyword) (remove-lambda-list-keywords (rest list)))
    (t (find-lambda-list-keyword keyword (rest list)))))

(defun find-lambda-list-keywords (list)
  (if (not (null list))
      (let ((rest (find-lambda-list-keywords (rest list))))
	(if (lambda-list-keyword-p (first list))
	    (acons (first list) (rest (assoc nil rest)) (remove nil rest :key #'first))
	    (acons nil (cons (first list) (rest (assoc nil rest))) (remove nil rest :key #'first))))))

(defun remove-lambda-list-keyword (keyword list)
  (cond ((null list) nil)
	((eq (first list) keyword)
	 (remove-lambda-list-keyword keyword (member-if #'lambda-list-keyword-p (rest list))))
	(t (cons (first list) (remove-lambda-list-keyword keyword (rest list))))))

(defun remove-lambda-list-keywords (list)
  (cond
    ((null list) nil)
    ((lambda-list-keyword-p (first list)) nil)
    (t (cons (first list) (remove-lambda-list-keywords (rest list))))))

(defun bind-normal-arguments (list args)
  (when (< (length args) (length list))
    (error "Not enought arguments for lambda list ~a in list ~a." list args))
  (list (mapcar #'cons list args)
	(nthcdr (length list) args)))

(defun bind-optional-arguments (list args)
  (labels ((bind-arg (arg value have-value-p)
	     (unless (listp arg) (setf arg (list arg)))
	     (dbind (name &optional default (set-flag nil set-flag-p)) arg
	       (if have-value-p
		   (acons name value (if set-flag-p (acons set-flag t nil)))
		   (acons name default (if set-flag-p (acons set-flag nil nil))))))
	   (do-bind (list args)
	     (if (not (null list))
		 (dbind (bindings rest) (do-bind (rest list) (rest args))
		   (list (append (bind-arg (first list) (first args) args) bindings)
			 rest))
		 (list nil args))))
    (do-bind list args)))

(defun bind-rest-argument (list args)
  (list (acons (first list) args nil)))

(defun bind-key-arguments (list arguments allow-other-keys)
  (labels ((argument-key (arg)
	     (let ((arg (if (listp arg) (first arg) arg)))
	       (if (listp arg) (first arg)
		   (make-keyword (symbol-name arg)))))
	   (argument-name (arg)
	     (let ((name-form (if (listp arg) (first arg) arg)))
	       (if (listp name-form) (second name-form) name-form)))
	   (argument-default (arg)
	     (if (listp arg) (second arg)))
	   (argument-set-arg (arg)
	     (if (listp arg) (third arg)))
	   (make-argument (spec)
	     (list (argument-key spec) (argument-name spec) (argument-default spec) nil (argument-set-arg spec))))
    (let ((keys (mapcar #'(lambda (arg) (make-argument arg)) list)))
      (flet ((bind-arg (key value)
	       (if (eq key :allow-other-keys)
		   (when value (setf allow-other-keys t))
		   (let ((arg (assoc key keys)))
		     (unless (or arg allow-other-keys)
		       (error "Wrong key argument ~a. Possible values are ~a." key (mapcar #'first keys)))
		     (when (and arg (not (fourth arg)))
		       (setf (third arg) value)
		       (setf (fourth arg) t))))))
	(labels ((do-bind (args)
		   (if args (progn (unless (rest args) (error "Odd number of key arguments in ~a." arguments))
				   (bind-arg (first args) (second args))
				   (do-bind (rest (rest args)))))))
	  (do-bind arguments)
	  (list (mapcan #'(lambda (key) (cons (cons (second key) (third key))
					      (aif (fifth key) (list (cons it (fourth key))))))
			keys)))))))

(defun bind-aux-arguments (list args)
  (declare (ignore args))
  (list (mapcar #'(lambda (arg) (if (listp arg) (cons (first arg) (second arg)) (cons arg nil))) list)))

(defmacro bind-keyword (keyword binder &rest args)
  `(awhen (assoc ',keyword keywords)
     (dbind (new-bindings &optional (new-rest nil new-rest-p)) (,binder (rest it) rest ,@args)
       (appendf bindings new-bindings)
       (when new-rest-p (setf rest new-rest)))))

(defun bind-lambda-list (list args &key macro-lambda-list-p (allowed-keywords nil allowed-keywords-p))
  (declare (ignore macro-lambda-list-p allowed-keywords))
  (let ((keywords (find-lambda-list-keywords list)))
    (dbind (bindings rest) (bind-normal-arguments (rest (assoc nil keywords)) args)
      (bind-keyword &optional bind-optional-arguments)
      (bind-keyword &rest bind-rest-argument)
      (bind-keyword &key bind-key-arguments (assoc '&allow-other-keys keywords))
      (bind-keyword &aux bind-aux-arguments)
      (when (and rest (not (assoc '&rest keywords)) (not (assoc '&key keywords)))
	(error "Too much arguments for lambda list ~a in list ~a." list args))
      bindings)))

(defun check-lambda-list (list &key macro-lambda-list-p (allowed-keywords nil allowed-keywords-p))
  (let* ((keywords (find-lambda-list-keywords list))
	 (names (mapcar #'first keywords)))
    (labels ((check-order (names keys)
	       (cond ((and (null keys) (not (null names))) (error "Wrong lambda list keywords ~a." names))
		     ((null keys) t)
		     (t (aif (position (first keys) names)
			     (if (not (= it 0)) (error "Wrong lambda list ~a." list)
				 (check-order (rest names) (rest keys)))
			     (check-order names (rest keys)))))))
      (check-order names '(nil &optional &rest &key &allow-other-keys &aux)))
    (labels ((check-once (names)
	       (cond
		 ((null names) t)
		 ((find (first names) (rest names)) (error "Wrong lambda list ~a." list))
		 (t (check-once (rest names))))))
      (check-once names))))
